# 常见面试题

## 1. redis中的RDB备份方式

bgsave开始时，会fork主机进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件.
fork采用的是copy-on-write技术：

+ 当主进程执行读操作时，访问共享数据；
+ 当主进程执行写操作时，则会拷贝一份数据，执行写操作。

_根据异步备份流程分析可得，当rdb子进程备份数据较慢时，整个redis服务所占用的内存可以达到所有数据的2倍，部署redis时，应该预留一部分内存给备份时使用。_

![vartar](images/redis-rdb.png)

RDB**触发条件**

+ 手动触发：save/bgsave
+ 自动触发: 满足redis配置文件中的自动触发条件RDB
+ 自动触发：每次关闭redis也会自动触发RDB
+ 自动触发：执行flushall命令也会自动触发RDB

redis**配置文件**

```bash
save 60 1000  # 每60秒内有1000次修改触发RDB
```

RDB**触发命令**

```bash
save        # save命令会阻塞redis服务的正常进程,直到RDB创建文件结束
bgsave      # bgsave会fork一个子进程,父进程继续处理了请求,不会影响redis服务,但是此时会拒绝客户端发送的save或bgsave命令,避免重复执行,竞争资源
flushall    # 用于清空整个redis服务器的数据
```

## 2. redis中的AOF备份方式

## 3. 过期策略

Redis的所有数据都可以设置过期时间，时间一到自动删除

### 过期的key集合

redis会将每个设置了过期时间的key放入到一个单独的字典中，以后会定时遍历这个字典来删除到期的key。除了定时遍历之外，还使用了惰性策略来删除过期的key，所谓惰性策略就是在客户端访问到这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除。定时删除是集中处理，惰性删除是零散处理

### 定时扫描策略

Redis默认会每秒进行10次过期扫描，过期扫描不会遍历字典中的所有key,而是采用了一种简单的贪心策略。

    1.从过期字典中随机选择20个key
    2.删除这20个key中过期的key
    3.如果过期的key比率超过1/4，就重复步骤一

同时保证扫描过期不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间上线，默认不会超出25ms.

### 仓库的过期策略

    从库不会执行过期策略，从库对过期的处理是被动的。主库在key到期时，会在AOF文件里增加一条del指
    令，同步到所有的从库，从库通过执行这条del指令来删除过期的key。
    因为指令同步是异步进行的，所以主库过期的key的del指令没有及时同步到从库，会出现主从数据不一致。

## 4. 物理内存超出时的过期策略 --LRU算法

当Redis内存超出物理内存限制时，内存的数据会开始和磁盘就行频繁的交换(如果swap开启的话)。 交换会让redis的性能急剧下降。
生产环境中redis提供了配置参数maxmemory来限制内存超出期望大小。
当实际使用内存超出maxmemory时，redis提供了几种可选策略，让维护者自己决定如何腾出新的内存空间继续提供读写服务

+ **noevicition** 服务不会继续处理写请求（del请求可以继续服务），读请求可以继续执行。

+ **volatitle-lru** 尝试淘汰设置了过期时间的key，最近最少使用的key优先被淘汰。没有设置过期时间的key不会被淘汰，这样可以保证需要持久化的数据不会突然丢失。

+ **volatitle-ttl** 尝试淘汰设置了过期时间的key, 剩余寿命ttl值越小，越被优先淘汰。

+ **volatitle-random** 尝试淘汰设置了过期时间的key， 淘汰的key是随机选择的。

+ **allkeys-lru** 这个淘汰策略的对象是所有的key，最近最少使用优先被淘汰。

+ **allkeys-random** 这个淘汰策略的对象是所有的key，淘汰的key是随机选择的。
