
[TOC]

# 消息队列

## 使用消息队列的场景

+ 消息队列的本质是先进先出的数据结构

+ 常见的应用场景：解耦，异步，削峰填谷

## 使用消息队列的优点和缺点

+ **优点：** 解耦，异步，削峰填谷

+ **缺点：** 系统可用性降低，系统复杂度提高，一致性问题

> 引入消息队列后，消息队列挂掉之后可能会影响业务系统的可用性
> 加入消息队列后，需要考虑多方面的问题，如何保证消息不被重复消费？如何保证消息的可靠传输？

## 如何保证消息队列不丢失

消息丢失的原因：

+ 生产者没有将消息发送到broker

+ 消息发送到broker后，broker宕机导致内存中的消息数据丢失

+ 消费者消费了消息，但是没有处理完就发生了异常，导致消息丢失

确保消息不丢失的方案

+ 发送方可靠发送

+ mq进行消息持久化

+ 消费者完成消费后就行ack确认，mq收到ack确认后再删除本地的消息

## 如何保证消息不被重复消费

消息重复的原因

+ 发送时消息重复

+ 消费时消息重复

消息重复发送问题

+ 消息发送者发送消息时，携带一个全局唯一的id

+ 消费者获取消息后先根据全局id，查询消息是否成功消费，

+ 消费过的消息直接丢弃

+ 未消费过的消息，消费完成后将id写入数据库或者redis

## 如何保证消息的有序性

+ **Kafka 消息顺序错乱**

对于 Kafka 来说，一个 topic 下同一个 partition 中的消息肯定是有序的，生产者在写的时候可以指定一个 key，通过我们会用订单号作为 key，这个 key 对应的消息都会发送到同一个 partition 中，所以消费者消费到的消息也一定是有序的。

那么为什么 Kafka 还会存在消息错乱的问题呢？问题就出在消费者身上。通常我们消费到同一个 key 的多条消息后，会使用多线程技术去并发处理来提高消息处理速度，否则一条消息的处理需要耗时几十 ms，1 秒也就只能处理几十条消息，吞吐量就太低了。而多线程并发处理的话，binlog 执行到数据库的时候就不一定还是原来的顺序了。

![kafka](/images/kafka-message.png)

+ **kafka保证消息的顺序性**

Kafka 从生产者到消费者消费消息这一整个过程其实都是可以保证有序的，导致最终乱序是由于消费者端需要使用多线程并发处理消息来提高吞吐量，比如消费者消费到了消息以后，开启 32 个线程处理消息，每个线程线程处理消息的快慢是不一致的，所以才会导致最终消息有可能不一致。

所以对于 Kafka 的消息顺序性保证，其实我们只需要保证同一个订单号的消息只被同一个线程处理的就可以了。由此我们可以在线程处理前增加个内存队列，每个线程只负责处理其中一个内存队列的消息，同一个订单号的消息发送到同一个内存队列中即可。

如下图是 Kafka 保证消息顺序性的方案：

![](/images/kafka-message2.png)
## 如何保证消息队列的高可用？

kafka：集群模式和并设置多个partition和多个replica机制

Kafka基本架构是多个broker组成，每个broker是一个节点，创建一个topic可以划分为多个partition，每个partition有多个副本，每个partition的数据都会同步到其他机器上，形成多个数据副本。然后所有的replica会选举出一个leader出来，生产和消费者都和这个leader打交道，其他副本都是follower。写的时候leader会负责把数据同步到多有的follower上，读的时候直接读leader上的数据。kafka会均匀的将一个partition上的所有replica分布到不同的机器上，提高容错性

## 延时队列

## 如何解决消息堆积问题

+ 检查并修复消费者，使其达到正常的消费速度

+ 将堆积的消息转存到容量更大的mq集群

+ 增加消费者节点并行消费堆积的消息，消费完毕后，恢复原始架构

## 消息过期

## MQ的通讯模式

1. 点对点通讯
2. 多点广播
3. 发布订阅模式
4. 集群（）

## 高性能相关(kafka吞吐量为什么这么大)

### 日志格式的演变

### 消息压缩

### 日志索引

### 消息顺序追加

### 页缓存

页缓存是操作系统实现的一种主要的磁盘缓存，以此来减少对磁盘的IO操作。

> vm.dirty_background_ratio参数用来指定档脏页数量达到系统内存的百分之多少之后就会出发pdflush/flush/kdmflush等后台回写进程来处理脏页
> vm.dirty_ratio参数，用来指定当脏页数量达到内存的百分之多少之后，不得不开始对脏页进行处理，再此过程中，新的IO请求会被阻塞直至所有脏页都被冲刷到磁盘中
> vm.dirty_expire_centisecs
> vm.dirty_writeback.centisecs
>

kafka同样提供了间断性强制刷盘的功能，kafka参数
> kafka参数
> log.flush.interval.messages
> log.flush.interval.ms

Linux Swap分区,

> vm.swappiness

### 磁盘IO流程及四种调度策略

1. NOOP
2. CFQ
3. DEADLINE
4. ANTICIPATORY

### 数据零拷贝

零拷贝是指将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序，大大提高了应用程序的性能，减少了内核和用户态之间的上下文切换。

### 消息队列支持扩容

