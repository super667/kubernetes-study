# 消息队列

## 使用消息队列的场景

+ 消息队列的本质是先进先出的数据结构

+ 常见的应用场景：解耦，异步，削峰填谷

## 使用消息队列的优点和缺点

+ **优点：** 解耦，异步，削峰填谷

+ **缺点：** 系统可用性降低，系统复杂度提高，一致性问题

> 引入消息队列后，消息队列挂掉之后可能会影响业务系统的可用性
> 加入消息队列后，需要考虑多方面的问题，如何保证消息不被重复消费？如何保证消息的可靠传输？

## 如何保证消息队列不丢失

消息丢失的原因：

+ 生产者没有将消息发送的broker

+ 消息发送到broker后，broker宕机导致内存中的消息数据丢失

+ 消费者消费了消息，但是没有处理完就发生了异常，导致消息丢失

确保消息不丢失的方案

+ 发送方可靠发送

+ mq进行消息持久化

+ 消费者完成消费后就行ack确认，mq收到ack确认后再删除本地的消息

## 如何保证消息不被重复消费

消息重复的原因

+ 发送时消息重复

+ 消费时消息重复

消息重复发送问题

+ 消息发送者发送消息时，携带一个全局唯一的id

+ 消费者获取消息后先根据全局id，查询消息是否成功消费，

+ 消费过的消息直接丢弃

+ 未消费过的消息，消费完成后将id写入数据库或者redis

## 如何保证消息的有序性

全局有序：


局部有序：

+ 生产者根据消息id将同一消息发送到一个队列中

## 如何保证消息队列的高可用？

kafka：集群模式和并设置多个partition和多个replica机制

Kafka基本架构是多个broker组成，每个broker是一个节点，创建一个topic可以划分为多个partition，每个partition有多个副本，每个partition的数据都会同步到其他机器上，形成多个数据副本。然后所有的replica会选举出一个leader出来，生产和消费者都和这个leader打交道，其他副本都是follower。写的时候leader会负责把数据同步到多有的follower上，读的时候直接读leader上的数据。kafka会均匀的将一个partition上的所有replica分布到不同的机器上，提高容错性

## 延时队列

## 如何解决消息堆积问题

+ 检查并修复消费者，使其达到正常的消费速度

+ 将堆积的消息转存到容量更大的mq集群

+ 增加消费者节点并行消费堆积的消息，消费完毕后，恢复原始架构

## 消息过期

## 高性能相关(kafka为什么这么快)

### 日志格式的演变

### 消息压缩

### 日志索引

### 消息顺序追加

### 页缓存

页缓存是操作系统实现的一种主要的磁盘缓存，以此来减少对磁盘的IO操作。

> vm.dirty_background_ratio参数用来指定档脏页数量达到系统内存的百分之多少之后就会出发pdflush/flush/kdmflush等后台回写进程来处理脏页
> vm.dirty_ratio参数，用来指定当脏页数量达到内存的百分之多少之后，不得不开始对脏页进行处理，再此过程中，新的IO请求会被阻塞直至所有脏页都被冲刷到磁盘中
> vm.dirty_expire_centisecs
> vm.dirty_writeback.centisecs
>

kafka同样提供了间断性强制刷盘的功能，kafka参数
> kafka参数
> log.flush.interval.messages
> log.flush.interval.ms

Linux Swap分区,

> vm.swappiness

### 磁盘IO流程及四种调度策略

1. NOOP
2. CFQ
3. DEADLINE
4. ANTICIPATORY

### 数据零拷贝

零拷贝是指将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序，大大提高了应用程序的性能，减少了内核和用户态之间的上下文切换。

> 零拷贝技术：
> 零拷贝技术依赖于底层的sendfile()方法的实现
> 正常情况下将一个静态文件A发动出去需要在一个进程调用两次函数
>
> read(file, tmp_buf, len);
> write(socket, tmp_buf, len);
>
> 这个过程，文件A经历了四次复制
>
> + 调用read方法时，文件A中的内容复制到了内核模式下的Read Buffer中。
>
> + CPU控制将内核模式数据复制到用户模式下。
> + 调用write时，将用户模式下的内容复制到内核模式下的socket Buffer中。
> + 将内核模式下的socket buffer的数据复制到网卡设备中
>
>![image](./images/%E9%9D%9E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF.png)
>
>
>![image](./images/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF.png)
> 零拷贝技术通过DMA技术将文件内容复制到内核模式下的Read Buffer中。不过没有数据被复制到Socket Buffer中，只把包含数据的位置和长度信息的文件描述符加载到Socket Buffer中。DMA引擎直接将数据从内核模式中传递到网卡设备。这里数据只经历了2次复制就从磁盘中传送出去。上下文切换也变成了2次。



### 消息队列支持扩容